{"meta":{"title":"Coding.Design.Cafe","subtitle":"Let it be,it will be.","description":null,"author":"Qiming","url":"http://www.bestcsser.cc"},"pages":[{"title":"categories","date":"2016-12-07T07:36:04.000Z","updated":"2016-12-18T06:15:06.000Z","comments":true,"path":"categories/index.html","permalink":"http://www.bestcsser.cc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2016-12-07T07:49:10.000Z","updated":"2016-12-18T06:15:06.000Z","comments":true,"path":"tags/index.html","permalink":"http://www.bestcsser.cc/tags/index.html","excerpt":"","text":""},{"title":"资源收集整理","date":"2016-12-09T06:58:21.000Z","updated":"2017-07-24T08:33:35.000Z","comments":true,"path":"src/index.html","permalink":"http://www.bestcsser.cc/src/index.html","excerpt":"","text":"CSS normalize.css CSS grid neat - A lightweight semantic grid framework built with Sass Gridforms - 网格表单 TOAST - Insane, no-nonsense CSS grid Animate Effeckt.css - 动画库:modal,button,list,tab… Tridiv - Creating 3D shapes in CSS animate.css Animista magic animations Effeckt Hover ihover SpinThatShit - CSSloader loaders.css css-loaders SPINNERS - HTML and CSS “loading icon” animations csspin - CSS Spinners and Loaders csshake - Some CSS classes to move your DOM Rocket - Rocket create an animation from two items via jQuery Animate Plus - CSS and SVG animation library textillate.js - CSS3 text animations mojs - 图形运动动画 缓动函数速查表 Framework Material Design Lite Pure - A set of small, responsive CSS modules materialize - Materialize, a CSS Framework based on Material Design Bulma - A modern CSS framework based on Flexbox bootflat-Flat UI KIT based on Bootstrap 3.3.0 CSS framework mui-Material Design CSS Framework Flexbox Patterns - Build awesome user interfaces with CSS flexbox Pintsize-Super flexbox picnic CoreUI-Free-Bootstrap-Admin-Template AdminLTE Control Panel Template Refills - Components and patterns built with Bourbon and Neat Flexbox Flexbox Grid - flexbox布局框架 RAGrid Flexbox Patterns solved-by-flexbox Flexibility - 各属性在线演示 flexplorer - 布局 Properties for the flex container - 各种示例 Flex属性示例 Components emoji-css awesome-bootstrap-checkbox css-toggle-switch simple-toggle-switch Utils devices.css - CSS (Mostly) Flat Mobile Devices Font Icons Font Awesome ionicons Material icons Iconfont - 阿里巴巴矢量图标库 javaScript Device.js - 设备判断 iOS, Android | Portrait vs. Landscape | Tablet vs. Mobile Clipboard.js - Copy to clipboard.No Flash jquery.adaptive - backgrounds-提取图片颜色并作为背景色显示 Percircle-CSS percentage circle built with jQuery jQuery Timer: Start/Stop/Resume/Remove TimeCircles Multi-select Fakecrop - Resize and crop bigger images and elements inside a container element jQThumb - 按比例显示缩略图 Intro.js - Introductions for websites and features with a step-by-step guide Basil.js - Unified localstorage, cookie and session storage JavaScript API LocalForage - localForage is a fast and simple storage library for JavaScript WebStorageCache - 对localStorage 和sessionStorage 进行了扩展，添加了超时时间，序列化方法 GridList - Drag and drop library for two-dimensional, resizable and responsive lists Notie - a clean and simple notification, input, and selection suite for javascript Slick - 轮播支持PC和Mobile SmallPop Split.js - 可拖动的布局 LazyLoad justlazy.js - micro javascript image lazy loading library tingle.js - A minimalist and easy-to-use modal plugin written in pure JavaScript Animate javaScript/CSS3 granim.js - 渐变动画/颜色/图片 anime.js shape-shifter led - canvas粒子文字插件 ScrollReveal - 滚动显示动画 bounce.js 移动端 lib.flexible - 移动端自适应方案 FastClick - 解决移动端浏览器 300 毫秒点击延迟问题 noclickdelay.js - 取消移动设备上click事件的300毫秒延迟 AlloyTouch - 腾讯AlloyTeam移动Web触摸解决方案 AlloyFinger - 多点触摸手势库 微信小程序 Wafer - 企业级微信小程序全栈方案 小相册 地图定位 豆瓣电影 购物车 番茄时钟 手机QQ 知乎日报 Apple Music wechat-app-music We重邮 - 微信小程序 wxapp-cli - 微信小程序脚手架 Vue.js Vue.js 2.0中文文档 Vuex - 状态管理模式 vue-router2 - 路由 vue-amap - 基于Vue2.0和高德地图的地图组件 mint-ui - Mobile UI elements for Vue.js element - A Vue.js 2.0 UI Toolkit for Web jackblog - vue 版个人博客系统 vux - 基于WeUI和Vue(2.x)开发的移动端UI组件库，主要服务于微信页面 VueStar - 点赞动画组件 NeteaseCloudWebApp - 网易云音乐 vue-ssr - vue服务端渲染模板 vue2-elm JSON Data 微票bannerList 微票playingList 微票cinemaList 知乎日报 AD’s API 远程数据接口代理服务 效率工具 bourbon - A Lightweight Sass Tool Set css3 cubic-bezier - 在线生成 css3 tools - css3动画工具 CSS3 Tool spy-debugger - 微信调试，各种WebView样式调试、手机浏览器的页面真机调试 前端构建脚手架 webpack-seed - 基于webpack搭建纯静态页面型前端工程解决方案模板 Webpack-Vue-MultiplePage - 在多页面项目下使用 Webpack + Vue jarvan4dev/vue-multi-page - 基于vue-cli脚手架修改而成的多页面(非SPA)项目脚手架 cooking-demo/multiple-pages-vue - Vue 2 + webpack 2 多页面例子 cooking-demo/simple - vue2+webpack2单页面 fis3-base - 基于fis3的纯前端解决方案 cooking - 基于 webapck 但更友好的配置项、易用的扩展配置机制 gulp-requirejs-boilerplate - 基于gulp+requirejs+less的多应用构建方案"}],"posts":[{"title":"VueRouter动态更新页面title","slug":"vue-router-updating-document-title","date":"2017-07-27T03:24:41.000Z","updated":"2017-07-27T04:15:41.000Z","comments":true,"path":"2017/07/27/vue-router-updating-document-title/","link":"","permalink":"http://www.bestcsser.cc/2017/07/27/vue-router-updating-document-title/","excerpt":"","text":"写在前面最近在折腾 vue 的时候，关于 vue-router，发现当切换不同页面的时候页面 title 是不会更新的。随后去找官方的文档，发现没有直接的方法来做这件事件，倒是有个路由元信息 meta，通过这个方法可以事先定义好路由的一些信息比如文档中的例子： 12345678910111213141516const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, children: [ { path: 'bar', component: Bar, // a meta field meta: { requiresAuth: true } } ] } ]}) 这样的话也可以定义各页面的 title: '登录'，如何取到 meta 中的数据，下面是文档中的例子： 那么如何访问这个 meta 字段呢？首先，我们称呼 routes 配置中的每个路由对象为 路由记录。路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。一个路由匹配到的所有路由记录会暴露为 $route 对象（还有在导航钩子中的 route 对象）的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta 字段。下面例子展示在全局导航钩子中检查 meta 字段： 12345678910111213141516router.beforeEach((to, from, next) => { if (to.matched.some(record => record.meta.requiresAuth)) { // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) { next({ path: '/login', query: { redirect: to.fullPath } }) } else { next() } } else { next() // 确保一定要调用 next() }}) 过程meta 中的数据取到后，该如何更新到 title， document.title = ...？ 通过搜索发现有人觉得把事先定义好的 title 保存在 vuex 中，在页面切换的时候去获取 store 中的 title。但是这个方法有点 “大材小用的感觉”，不喜欢。 然后找到 github vue-router Issues https://github.com/vuejs/vue-router/issues/112 中的讨论。 方法@roninliu给到的方法： 123456789101112131415//in router config{ path: \"/login\", name: \"login\", component: LoginView, meta: { title: 'Login System' }}//in init router filerouter.afterEach(route => { document.title = route.meta.title;}) 一点点思考最近一直在熟悉vue的开发，给我的感觉也是简单易上手，虽然自己的javaScript基础相对弱，还好在遇到问题的时候通过搜索能够解决难题，这就是互联网共享的价值吧。 同时也一直在看一些前端开发相关的文章，还是发现各种工具框架层出不穷，感觉过不了个把月可能当下你用的工具就过时了，不如 npm，现在的 yarn …… 作为前端开发，有时也觉得各位大神究竟在折腾个啥呢。 最后，基础是一切之根基。在折腾各种框架工具的同时还是要时刻提升自己的基础知识。 路漫漫其修远兮","categories":[{"name":"vue","slug":"vue","permalink":"http://www.bestcsser.cc/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://www.bestcsser.cc/tags/vue/"},{"name":"vue-router","slug":"vue-router","permalink":"http://www.bestcsser.cc/tags/vue-router/"}]},{"title":"ECMAScript 6 入门 -- Promise","slug":"es6tutorial-promise","date":"2017-07-23T12:33:46.000Z","updated":"2017-07-27T03:30:03.000Z","comments":true,"path":"2017/07/23/es6tutorial-promise/","link":"","permalink":"http://www.bestcsser.cc/2017/07/23/es6tutorial-promise/","excerpt":"","text":"转载：阮一峰 ECMAScript 6入门 Promise 的含义Promise 是异步编程的一种解决方案。所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise 对象有以下两个特点。 (1) 对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 (2) 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 基本用法ES6 规定，Promise 对象是一个构造函数，用来生成 Promise 实例。创造一个 Promise 实例： 123456789var promise = new Promise(function(resolve, resject){ // do something if( /* 异步操作成功 */ ){ resolve(value) } else { resject(error) }}) Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 和 reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve 函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 Pending 变为 Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject 函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 Pending 变为 Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise 实例生成以后，可以用 then 方法分别指定Resolved状态和Reject状态的回调函数。 12345promise.then(function(value){ // success}, function(error){ // failure}) then 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子： 123456789function timeout(ms) { return new Promise((resolve, reject) => { setTomeout(resolve, ms, 'done'); })}timeout(100).then((value) => { console.log(value)}) 上面代码中，timeout 方法返回一个 Promise 实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise 新建后就会立即执行。 1234567891011let promise = new Promise(function(resolve, reject){ console.log('Promise') resolve()})promise.then(function(){ console.log('Resolved')})console.log('Hi!')// Promise// Resolved// Hi! 上面代码中，Promise新建后立即执行，所以首先输出的是 Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以Resolved最后输出。 下面是异步加载图片的例子。 1234567891011121314function loadImageAsync(url) { return new Promise(function(resolve, reject){ var image = new Image() image.onload = function() { resolve(image) } image.onerror = function() { reject( new Error('Could not load image at ' + url) ) } image.src = url })} 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 123456789101112131415161718192021222324252627282930var getJSON = function(url) { var promise = new Promise(function(resolve, reject){ var client = new XMLHttpRequest() client.open('GET', url) client.onreadystatechange = handler client.responeType = 'json' client.setRequestHeader('Accept', 'application/json') client.send() function handler() { if( this.readyState !== 4 ){ return } if( this.status === 200 ) { resolve(this.response) } else { reject( new Error(this.statusText) ) } } }) return promise}getJSON('/post.json').then(function(json){ console.log('Contents: ' + json);}, function(error) { console.error('出错了', error);}) 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 12345678var p1 = new Promise(function (resolve, reject) { // ...});var p2 = new Promise(function (resolve, reject) { // ... resolve(p1);}) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。 12345678910111213141516var p1 = new Promise(function (resolve, reject) { setTimeout(function(){ return reject(new Error('fail')) }, 3000)});var p2 = new Promise(function (resolve, reject) { setTimeout(function(){ return resolve(p1) }, 1000)})p2.then(function(result){ console.log(result)}).catch(function(error){ console.log(error)}) 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 12345678new Promise((resolve, reject) => { resolve(1); console.log(2);}).then(r => { console.log(r);});// 2// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 12345new Promise((resolve, reject) => { return resolve(1); // 后面的语句不会执行 console.log(2);})","categories":[{"name":"javaScript日常笔记","slug":"javaScript日常笔记","permalink":"http://www.bestcsser.cc/categories/javaScript日常笔记/"}],"tags":[{"name":"promise","slug":"promise","permalink":"http://www.bestcsser.cc/tags/promise/"}]},{"title":"[转载]数组Array.prototype方法的使用","slug":"ES5-array-prototype","date":"2017-07-20T15:19:57.000Z","updated":"2017-07-20T15:53:36.000Z","comments":true,"path":"2017/07/20/ES5-array-prototype/","link":"","permalink":"http://www.bestcsser.cc/2017/07/20/ES5-array-prototype/","excerpt":"","text":"熟悉数组Array.prototype方法的使用 转载：你还在用for循环大法麽 常用数组方法 indexOf()indexOf() 方法返回在该数组中第一个找到的元素位置，没有则返回 -1 使用 for:12345678var arr = ['apple','orange','pear'], found = false;for(var i= 0, l = arr.length; i< l; i++){ if(arr[i] === 'orange'){ found = true; }}console.log(\"found:\",found); 使用 indexOf:12var arr = ['apple','orange','pear']; console.log(\"found:\", arr.indexOf(\"orange\") != -1); lastindexOf()lastindexOf() 方法返回在该数组中最后一个找到的元素位置，与 indexOf 相反 every()every() 可以监测数组中的每一项是否符合条件 使用 for: 12345678910111213/* * 是否全部大于0*/var ary = [12,23,24,42,1];var result = function(){ for (var i = 0; i < ary.length; i++) { if(ary[i] < 0){ return false; } } return true; //需全部满足}console.log(result()) //全部满足,返回true 使用 every:12345var ary = [12,23,24,42,1];var result = ary.every(function(item, index){ return item > 0})console.log(result) some()some() 可以监测数组中的某一项是否符合条件 使用 for:12345678910111213/* * 是否存在小于0的项*/var ary = [12,23,-24,42,1];var result = function(){ for (var i = 0; i < ary.length; i++) { if(ary[i] < 0){ return true; } } return false; //只需满足一个}console.log(result()) //有一项小于0，返回true 使用 some:12345var ary = [12,23,-24,42,1];var result = ary.some(function(item, index){ return item < 0})console.log(result) forEach()forEach() 为每个元素执行对应的方法，是用来替换for循环的 使用 for:12345var arr = [1,2,3,4,5,6,7,8];for(var i= 0, l = arr.length; i< l; i++){ console.log(arr[i]);} 使用 forEach:12345var arr = [1,2,3,4,5,6,7,8];arr.forEach(function(item,index){ console.log(item);}); map()‘map()’ 对数组的每个元素进行一定操作（映射）后，会返回一个新的数组，是处理服务器返回数据时是一个非常实用的函数 使用 for:1234567891011121314151617181920var oldArr = [{ first_name:\"Colin\",last_name:\"Toh\" }, { first_name:\"Addy\",last_name:\"Osmani\" }, { first_name:\"Yehuda\",last_name:\"Katz\" }];function getNewArr(){ var newArr = []; for(var i= 0, l = oldArr.length; i< l; i++){ var item = oldArr[i]; item.full_name = [item.first_name,item.last_name].join(\" \"); newArr[i] = item; } return newArr;}console.log(getNewArr()); 使用 map:123456789101112131415161718var oldArr = [{ first_name:\"Colin\",last_name:\"Toh\" }, { first_name:\"Addy\",last_name:\"Osmani\" }, { first_name:\"Yehuda\",last_name:\"Katz\" }];function getNewArr(){ return oldArr.map(function(item,index){ item.full_name = [item.first_name,item.last_name].join(\" \"); return item; });}console.log(getNewArr()); forEach 与 map 的区别语法： forEach 和 map 都支持2个参数：一个是回调函数（item,index,list）和 上下文； forEach：用来遍历数组中的每一项；这个方法执行是没有返回值的，对原来数组也没有影响；数组中有几项，那么传递进去的匿名回调函数就需要执行几次；每一次执行匿名函数的时候，还给其传递了三个参数值：数组中的当前项item,当前项的索引index,原始数组list；理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是我们可以自己通过数组的索引来修改原来的数组； forEach 方法中的 this 是 ary,匿名回调函数中的 this 默认是 window； 123456var ary = [12,23,24,42,1];var res = ary.forEach(function (item,index,input) { input[index] = item*10;})console.log(res);//-->undefined;console.log(ary);//-->会对原来的数组产生改变； map： 和 forEach 非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项；区别：map的回调函数中支持 return 返回值；return 的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）； 不管是forEach还是map 都支持第二个参数值，第二个参数的意思是把匿名回调函数中的this进行修改。 123456var ary = [12,23,24,42,1];var res = ary.map(function (item,index,input) { return item*10;})console.log(res);//-->[120,230,240,420,10];console.log(ary);//-->[12,23,24,42,1]； filter()filter() 方法创建一个新的匹配过滤条件的数组 使用 for: 12345678910111213var arr = [ {\"name\":\"apple\", \"count\": 2}, {\"name\":\"orange\", \"count\": 5}, {\"name\":\"pear\", \"count\": 3}, {\"name\":\"orange\", \"count\": 16},];var newArr = [];for(var i= 0, l = arr.length; i< l; i++){ if(arr[i].name === \"orange\" ){ newArr.push(arr[i]); }}console.log(\"Filter results:\",newArr); 使用 filter: 12345678910var arr = [ {\"name\":\"apple\", \"count\": 2}, {\"name\":\"orange\", \"count\": 5}, {\"name\":\"pear\", \"count\": 3}, {\"name\":\"orange\", \"count\": 16},];var newArr = arr.filter(function(item){ return item.name === \"orange\";});console.log(\"Filter results:\",newArr); reduce()我好像不理解这东西，原文就不放了……暂空 isArray()isArray() 是Array对象的一个静态函数，用来判断一个对象是不是数组 123456789101112131415var ary1 = [];var res1 = Array.isArray(ary1); // Output: trueconsole.log(res1)var ary2 = new Array();var res2 = Array.isArray(ary2); // Output: trueconsole.log(res2)var ary3 = [1, 2, 3];var res3 = Array.isArray(ary3); // Output: trueconsole.log(res3)var ary4 = new Date();var res4 = Array.isArray(ary4); // Output: falseconsole.log(res4) 数组的增加、删除和修改push()向数组末尾增加新的内容，返回的是添加后新数组的长度,原有的数组改变了 1234var arr = [10,11,12,13,14,15];var res = arr.push(16,17);console.log(res); //8console.log(arr); //[10,11,12,13,14,15,16,17] unshift()向数组的开头增加新的内容，返回的是添加后新数组的长度，原来的数组也改变 12var res = arr.unshift(16,17);console.log(res); //8 splice(n,m,x)把原有数组中的某些项进行替换。（先删除，然后用x替换）。从索引n（包含n）开始，向后删除m个元素，用x替换，返回删除的数组 原有数组改变规律： splice(0,0,x) 相当于unshift，splice(arr.length,0,x) 相当于push，splice(n,0,x) 向数组中间某个位置添加新的内容，从索引n开始，删除0个内容，把新增的内容x放在索引n的前面。返回的是一个空数组，原有数组改变n开始的索引 splice(n,m) 删除数组指定项，从所以n（包含n）开始，向后删除m个元素 ，把删除的内容当做新数组返回，原有数组改变。 12var res = arr.splice(2,0,\"michael\"); //在12后面添加“michael\"console.log(arr); pop()删除数组最后一个，返回的是删除的那一项，原有数组改变。 shift()删除数组第一个，返回的是删除的那一项，原有数组改变。 数组的查询和复制slice(n,m)从索引 n（包含n）开始找到索引 m (不包含m)处。把找到的内容作为一个新的数组返回，原有数组是不改变的。 123456var arr = [10,11,12,13,14,15];var res = arr.slice(1,4);console.log(res); //[11, 12, 13]console.log(arr); //[10, 11, 12, 13, 14, 15]slice(n) // 从索引n（包含n）开始找到末尾slice(0) // slice() 将原来数组原封不动的复制一份，数组clone concat()本意是实现数组的拼接的 arr1.concat(arr2) 将数组 arr2 和 arr1 合并成新的数组，原来的数组也不变。 concat 也可以是数组的克隆，原来的数组也改变（相当于 slice(0))。 12345var arr1=[10,11,12,13,14,15];var arr2=[16,17];var res=arr1.concat(arr2);console.log(arr1); //[10, 11, 12, 13, 14, 15]console.log(res); //[10, 11, 12, 13, 14, 15, 16, 17] 将数组转化为需要的字符串toString()把数组中的每一项拿出来，用逗号隔开，组成字符串，原有数组不变。 1234var arr = [\"name\",\"michael\",\"age\",\"24\"];var res = arr.toString();console.log(res); //name,michael,age,24console.log(arr); //[\"name\", \"michael\", \"age\", \"24\"] join()把数组中的每一项拿出来，用指定的分隔符隔开，原有数组不变。 123456var arr = [\"name\",\"michael\",\"age\",\"24\"];var res = arr.join(\"|\");console.log(res); //\"name|michael|age|24\"console.log(res.length); //19console.log(arr); //[\"name\", \"michael\", \"age\", \"24\"]console.log(arr.length); //4 实现数组中数字的求和： 12345var arr = [10,11,12,13,14,15];var str = arr.join(\"+\"); //\"10+11+12+13+14+15\"var total = eval(str); //eval 将指定的字符串变成真正的额表达式执行console.log(total); //75console.log(arr); //[10, 11, 12, 13, 14, 15] 排列和排序reverse()数组倒过来排列，原有数组改变。 1234var arr = [10,11,12,13,14,15];console.log(arr); //[10, 11, 12, 13, 14, 15]var res = arr.reverse(); //\"10+11+12+13+14+15\"console.log(res); //[15, 14, 13, 12, 11, 10] sort()数组的排序，可以实现由大到小（由小到大），原有的数组也变。 直接写 sort 只能处理10以内的数字排序,处理10以上的我们需要传递一个参数，这个参数必须是函数。 1234var arr = [10,12,11,19,13,15,6];console.log(arr); //[10, 12, 11, 19, 13, 15,6]var res = arr.sort();console.log(res); //[10, 11, 12, 13, 15, 19, 6] 改进： 123456789101112131415var arr = [10,12,11,19,13,15,6];console.log(arr); //[10, 12, 11, 19, 13, 15,6]var res1 = arr.sort(function(a,b){return a-b;}); //实现由小到大console.log(res1);var res2 = arr.sort(function(a,b){return b-a;}) //实现由大到小console.log(res2); //[10, 11, 12, 13, 15, 19, 6]var arr = [10,12,11,19,13,6];console.log(arr); //[10, 12, 11, 19, 13, 15,6]var res1 = arr.sort(function(a,b){//a表示每一次循环的时候的当前项，b是后面的项//return a-b;当前项减去后一项，如果大于0，代表前面的比后面的大，这样的话就交换位置//冒泡排序：sort实现排序，就是遵循冒泡排序的思想实现的console.log(a+\"\"+b);return a-b;}); //实现由小到大","categories":[{"name":"javaScript日常笔记","slug":"javaScript日常笔记","permalink":"http://www.bestcsser.cc/categories/javaScript日常笔记/"}],"tags":[{"name":"array","slug":"array","permalink":"http://www.bestcsser.cc/tags/array/"}]},{"title":"ECMAScript 6 入门 -- Module 的语法","slug":"es6tutorial-module","date":"2017-05-09T07:28:44.000Z","updated":"2017-05-09T14:07:25.000Z","comments":true,"path":"2017/05/09/es6tutorial-module/","link":"","permalink":"http://www.bestcsser.cc/2017/05/09/es6tutorial-module/","excerpt":"","text":"转载：阮一峰 ECMAScript 6入门 概述历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 12345678// CommonJS模块let { stat, exists, readFile } = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 12// ES6模块import { stat, exists, readFile } from 'fs'; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 本章介绍 ES6 模块的语法，下一章介绍如何在浏览器和 Node 之中，加载 ES6 模块。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上\"use strict\";。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。 其中，尤其需要注意this的限制。ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 export 命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 1234// profile.jsexport var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 上面代码是profile.js文件，保存了用户信息。ES6 将其视为一个模块，里面用export命令对外部输出了三个变量。 export的写法，除了像上面这样，还有另外一种。 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export {firstName, lastName, year}; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 123export function multiply(x, y) { return x * y;}; 上面代码对外输出一个函数multiply。 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() { ... }function v2() { ... }export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion}; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。 12345678910// 写法一export var m = 1;// 写法二var m = 1;export {m};// 写法三var n = 1;export {n as m}; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 12345678910// 报错function f() {}export f;// 正确export function f() {};// 正确function f() {}export {f}; 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 12export var foo = 'bar';setTimeout(() => foo = 'baz', 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 1234function foo() { export default 'bar' // SyntaxError}foo() 上面代码中，export语句放在函数之中，结果报错。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 123456// main.jsimport {firstName, lastName, year} from './profile';function setName(element) { element.textContent = firstName + ' ' + lastName;} 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import { lastName as surname } from './profile'; import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 1import {myMethod} from 'util'; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 123foo();import { foo } from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 12345678910111213// 报错import { 'f' + 'oo' } from 'my_module';// 报错let module = 'my_module';import { foo } from module;// 报错if (x === 1) { import { foo } from 'module1';} else { import { foo } from 'module2';} 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 最后，import语句会执行所加载的模块，因此可以有下面的写法。 1import 'lodash'; 上面代码仅仅执行lodash模块，但是不输入任何值。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 12import 'lodash';import 'lodash'; 上面代码加载了两次lodash，但是只会执行一次。 12345import { foo } from 'my_module';import { bar } from 'my_module';// 等同于import { foo, bar } from 'my_module'; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 123456789// circle.jsexport function area(radius) { return Math.PI * radius * radius;}export function circumference(radius) { return 2 * Math.PI * radius;} 现在，加载这个模块。 123456// main.jsimport { area, circumference } from './circle';console.log('圆面积：' + area(4));console.log('圆周长：' + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 1234import * as circle from './circle';console.log('圆面积：' + circle.area(4));console.log('圆周长：' + circle.circumference(14)); 注意，模块整体加载所在的那个对象（上例是circle），应该是可以静态分析的，所以不允许运行时改变。下面的写法都是不允许的。 12345import * as circle from './circle';// 下面两行都是不允许的circle.foo = 'hello';circle.area = function () {}; export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 1234// export-default.jsexport default function () { console.log('foo');} 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 123// import-default.jsimport customName from './export-default';customName(); // 'foo' 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的。 123456789101112// export-default.jsexport default function foo() { console.log('foo');}// 或者写成function foo() { console.log('foo');}export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 下面比较一下默认输出和正常输出。 12345678910111213// 第一组export default function crc32() { // 输出 // ...}import crc32 from 'crc32'; // 输入// 第二组export function crc32() { // 输出 // ...};import {crc32} from 'crc32'; // 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 123456789101112// modules.jsfunction add(x, y) { return x * y;}export {add as default};// 等同于// export default add;// app.jsimport { default as xxx } from 'modules';// 等同于// import xxx from 'modules'; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 123456789// 正确export var a = 1;// 正确var a = 1;export default a;// 错误export default var a = 1; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 同样地，因为export default本质是将该命令后面的值，赋给default变量以后再默认，所以直接将一个值写在export default之后。 12345// 正确export default 42;// 报错export 42; 上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定外对接口为default。 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 1import _ from 'lodash'; 如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。 1import _, { each } from 'lodash'; 对应上面代码的export语句如下。 123456789export default function (obj) { // ···}export function each(obj, iterator, context) { // ···}export { each as forEach }; 上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 export default也可以用来输出类。 123456// MyClass.jsexport default class { ... }// main.jsimport MyClass from 'MyClass';let o = new MyClass(); export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 12345export { foo, bar } from 'my_module';// 等同于import { foo, bar } from 'my_module';export { foo, bar }; 上面代码中，export和import语句可以结合在一起，写成一行。 模块的接口改名和整体输出，也可以采用这种写法。 12345// 接口改名export { foo as myFoo } from 'my_module';// 整体输出export * from 'my_module'; 默认接口的写法如下。 1export { default } from 'foo'; 具名接口改为默认接口的写法如下。 12345export { es6 as default } from './someModule';// 等同于import { es6 } from './someModule';export default es6; 同样地，默认接口也可以改名为具名接口。 1export { default as es6 } from './someModule'; 下面三种import语句，没有对应的复合写法。 123import * as someIdentifier from \"someModule\";import someIdentifier from \"someModule\";import someIdentifier, { namedIdentifier } from \"someModule\"; 为了做到形式的对称，现在有提案，提出补上这三种复合写法。 123export * as someIdentifier from \"someModule\";export someIdentifier from \"someModule\";export someIdentifier, { namedIdentifier } from \"someModule\"; 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 1234567// circleplus.jsexport * from 'circle';export var e = 2.71828182846;export default function(x) { return Math.exp(x);} 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 123// circleplus.jsexport { area as circleArea } from 'circle'; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下。 12345// main.jsimport * as math from 'circleplus';import exp from 'circleplus';console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。 1234567891011121314// constants.js 模块export const A = 1;export const B = 3;export const C = 4;// test1.js 模块import * as constants from './constants';console.log(constants.A); // 1console.log(constants.B); // 3// test2.js 模块import {A, B} from './constants';console.log(A); // 1console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 123456789// constants/db.jsexport const db = { url: 'http://my.couchdbserver.local:5984', admin_username: 'admin', admin_password: 'admin password'};// constants/user.jsexport const users = ['root', 'admin', 'staff', 'ceo', 'chief', 'moderator']; 然后，将这些文件输出的常量，合并在index.js里面。 123// constants/index.jsexport {db} from './db';export {users} from './users'; 使用的时候，直接加载index.js就可以了。 12// script.jsimport {db, users} from './constants'; import()简介前面介绍过，import命令会被 JavaScript 引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。所以，下面的代码会报错。 1234// 报错if (x === 2) { import MyModual from './myModual';} 上面代码中，引擎处理import语句是在编译时，这时不会去分析或执行if语句，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。也就是说，import和export命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从语法上，条件加载就不可能实现。如果import命令要取代 Node 的require方法，这就形成了一个障碍。因为require是运行时加载模块，import命令无法取代require的动态加载功能。 12const path = './' + fileName;const myModual = require(path); 上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import语句做不到这一点。 因此，有一个提案，建议引入import()函数，完成动态加载。 1import(specifier) 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import命令能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。下面是一个例子。 123456789const main = document.querySelector('main');import(`./section-modules/${someVariable}.js`) .then(module => { module.loadPageInto(main); }) .catch(err => { main.textContent = err.message; }); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 适用场合下面是import()的一些适用场合。 （1）按需加载。 import()可以在需要的时候，再加载某个模块。 123456789button.addEventListener('click', event => { import('./dialogBox.js') .then(dialogBox => { dialogBox.open(); }) .catch(error => { /* Error handling */ })}); 上面代码中，import()方法放在click事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。 （2）条件加载 import()可以放在if代码块，根据不同的情况，加载不同的模块。 12345if (condition) { import('moduleA').then(...);} else { import('moduleB').then(...);} 上面代码中，如果满足条件，就加载模块 A，否则加载模块 B。 （3）动态的模块路径 import()允许模块路径动态生成。 12import(f()).then(...); 上面代码中，根据函数f的返回结果，加载不同的模块。 注意点import()加载模块成功以后，这个模块会作为一个对象，当作then方法的参数。因此，可以使用对象解构赋值的语法，获取输出接口。 1234import('./myModule.js').then(({export1, export2}) => { // ...·}); 上面代码中，export1和export2都是myModule.js的输出接口，可以解构获得。 如果模块有default输出接口，可以用参数直接获得。 1234import('./myModule.js').then(myModule => { console.log(myModule.default);}); 上面的代码也可以使用具名输入的形式。 1234import('./myModule.js').then(({default: theDefault}) => { console.log(theDefault);}); 如果想同时加载多个模块，可以采用下面的写法。 12345678Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'),]).then(([module1, module2, module3]) => { ···}); import()也可以用在 async 函数之中。 1234567891011async function main() { const myModule = await import('./myModule.js'); const {export1, export2} = await import('./myModule.js'); const [module1, module2, module3] = await Promise.all([ import('./module1.js'), import('./module2.js'), import('./module3.js'), ]);}main();","categories":[{"name":"javaScript日常笔记","slug":"javaScript日常笔记","permalink":"http://www.bestcsser.cc/categories/javaScript日常笔记/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://www.bestcsser.cc/tags/es6/"}]},{"title":"JavaScript高级程序设计 -- 数据类型","slug":"javascript-basic","date":"2017-04-19T05:55:41.000Z","updated":"2017-05-09T14:07:25.000Z","comments":true,"path":"2017/04/19/javascript-basic/","link":"","permalink":"http://www.bestcsser.cc/2017/04/19/javascript-basic/","excerpt":"","text":"摘录：《JavaScript高级程序设计》第三版 数据类型ECMAScript 中有5 种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number 和 String。还有1 种复杂数据类型—— Object，Object 本质上是由一组无序名值对组成的。ECMAScript 不支持任何创建自定义类型的机制，而所有值最终都将是上述6 种数据类型之一。乍一看，好像只有6种数据类型不足以表示所有数据；但是，由于ECMAScript 数据类型具有动态性，因此的确没有再定义其他数据类型的必要了。 typeof 操作符鉴于ECMAScript 是松散类型的，因此需要有一种手段来检测给定变量的数据类型—— typeof 就是负责提供这方面信息的操作符。对一个值使用typeof 操作符可能返回下列某个字符串： undefined 如果这个值未定义 boolean 如果这个值是布尔值 string 如果这个值是字符串 number 如果这个值是数值 object 如果这个值是对象或null function 如果这个值是函数 下面是几个使用typeof 操作符的例子： 1234var message = \"some string\";console.log(typeof message); // \"string\"console.log(typeof(message)); // \"string\"console.log(typeof 95); // \"number\" 这几个例子说明，typeof 操作符的操作数可以是变量（message），也可以是数值字面量。注意，typeof 是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值。比如，调用 typeof null 会返回 object，因为特殊值 null 被认为是一个空的对象引用。Safari 5 及之前版本、Chrome 7 及之前版本在对正则表达式调用 typeof 操作符时会返回 function，而其他浏览器在这种情况下会返回 object。 从技术角度讲，函数在 ECMAScript 中是对象，不是一种数据类型。然而，函数也确实有一些特殊的属性，因此通过 typeof 操作符来区分函数和其他对象是有必要的。 Undefined 类型Undefined 类型只有一个值，即特殊的 undefined 。在使用 var 声明变量但未对其加以初始化时，这个变量的值就是 undefined，例如： 12var message;console.log(message == undefined); //true 这个例子只声明了变量message，但未对其进行初始化。比较这个变量与 undefined 字面量，结果表明它们是相等的。这个例子与下面的例子是等价的： 12var message = undefined;console.log(message == undefined); //true 这个例子使用 undefined 值显式初始化了变量message。但我们没有必要这么做，因为未经初始化的值默认就会取得 undefined 值。 一般而言，不存在需要显式地把一个变量设置为 undefined 值的情况。字面值 undefined 的主要目的是用于比较，而ECMA-262 第3 版之前的版本中并没有规定这个值。第3 版引入这个值是为了正式区分空对象指针与未经初始化的变量。 不过，包含 undefined 值的变量与尚未定义的变量还是不一样的。看看下面这个例子： 12345var message; // 这个变量声明之后默认取得了undefined 值// 下面这个变量并没有声明// var ageconsole.log(message); // \"undefined\"console.log(age); // 产生错误 运行以上代码，第一个警告会显示变量 message 的值，即”undefined”。而第二个警告——由于传递给 console.log() 是尚未声明的变量 age ——则会导致一个错误。对于尚未声明过的变量，只能执行一项操作，即使用typeof 操作符测其数据类型（对未经声明的变量调用delete 不会导致错误，但这样做没什么实际意义，而且在严格模式下确实会导致错误）。 然而，令人困惑的是：对未初始化的变量执行 typeof 操作符会返回 undefined 值，而对未声明的变量执行 typeof 操作符同样也会返回 undefined 值。来看下面的例子： 12345var message; // 这个变量声明之后默认取得了undefined 值// 下面这个变量并没有声明// var ageconsole.log(typeof message); // \"undefined\"console.log(typeof age); // \"undefined\" 结果表明，对未初始化和未声明的变量执行 typeof 操作符都返回了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操作。 即便未初始化的变量会自动被赋予 undefined 值，但显式地初始化变量依然是明智的选择。如果能够做到这一点，那么当 typeof 操作符返回 undefined 值时，我们就知道被检测的变量还没有被声明，而不是尚未初始化。 Null 类型Null 类型是第二个只有一个值的数据类型，这个特殊的值是 null 。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回 object 的原因，如下面的例子所示： 12var car = null;console.log(typeof car); // \"object\" 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为 null 而不是其他值。这样一来，只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用，如下面的例子所示： 123if (car != null){// 对car 对象执行某些操作} 实际上，undefined 值是派生自 null 值的，因此ECMA-262 规定对它们的相等性测试要返回true： 1console.log(null == undefined); //true 这里，位于 null 和 undefined 之间的相等操作符（==）总是返回 true，不过要注意的是，这个操作符出于比较的目的会转换其操作数（本章后面将详细介绍相关内容）。尽管 null 和 undefined 有这样的关系，但它们的用途完全不同。如前所述，无论在什么情况下都没有必要把一个变量的值显式地设置为 undefined，可是同样的规则对 null 却不适用。换句话说，只要意在保存对象的变量还没有真正保存对象，就应该明确地让该变量保存null 值。这样做不仅可以体现null 作为空对象指针的惯例，而且也有助于进一步区分null 和undefined。 Boolean 类型Boolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。这两个值与数字值不是一回事，因此 true 不一定 等于1，而 false 也不一定等于0。以下是为变量赋 Boolean 类型值的例子： 12var found = true;var lost = false; 需要注意的是，Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说，True 和 False（以及其他的混合大小写形式）都不是 Boolean 值，只是标识符。虽然 Boolean 类型的字面值只有两个，但ECMAScript 中所有类型的值都有与这两个 Boolean 值等价的值。要将一个值转换为其对应的 Boolean 值，可以调用转型函数 Boolean()，如下例所示： 12var message = \"Hello world!\";var messageAsBoolean = Boolean(message); 在这个例子中，字符串 message 被转换成了一个 Boolean 值，该值被保存在 messageAsBoolean 变量中。可以对任何数据类型的值调用 Boolean() 函数，而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false，取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。 数据类型 转换为true的值 转换为false的值 Boolean true false String 任何非空字符串 “”（空字符串） Number 任何非零数字值（包括无穷大） 0和NaN（参见本章后面有关NaN的内容） Object 任何对象 null Undefined N/A undefined 这些转换规则对理解流控制语句（如if 语句）自动执行相应的 Boolean 转换非常重要，请看下面的代码： 1234var message = \"Hello world!\";if (message){ alert(\"Value is true\");} 运行这个示例，就会显示一个警告框，因为字符串 message 被自动转换成了对应的 Boolean 值（true）。由于存在这种自动执行的Boolean 转换，因此确切地知道在流控制语句中使用的是什么变量至关重要。错误地使用一个对象而不是一个 Boolean 值，就有可能彻底改变应用程序的流程。 Number 类型Number 类型应该是ECMAScript 中最令人关注的数据类型了，这种类型使用IEEE754 格式来表示整数和浮点数值（浮点数值在某些语言中也被称为双精度数值）。为支持各种数值类型，ECMA-262 定义了不同的数值字面量格式。 最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入： 1var intNum = 55; // 整数 除了以十进制表示外，整数还可以通过八进制（以8 为基数）或十六进制（以16 为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0～7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。请看下面的例子： 123var octalNum1 = 070; // 八进制的56var octalNum2 = 079; // 无效的八进制数值——解析为79var octalNum3 = 08; // 无效的八进制数值——解析为8 八进制字面量在严格模式下是无效的，会导致支持该模式的JavaScript 引擎抛出错误。十六进制字面值的前两位必须是0x，后跟任何十六进制数字（0～9 及A～F）。其中，字母A～F可以大写，也可以小写。如下面的例子所示： 12var hexNum1 = 0xA; // 十六进制的10var hexNum2 = 0x1f; // 十六进制的31 在进行算术计算时，所有以八进制和十六进制表示的数值最终都将被转换成十进制数值。 鉴于 JavaScript 中保存数值的方式，可以保存正零（+0）和负零（-0）。正零和负零被认为相等，但为了读者更好地理解上下文，这里特别做此说明。 浮点数值所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法。以下是浮点数值的几个例子： 123var floatNum1 = 1.1;var floatNum2 = 0.1;var floatNum3 = .1; // 有效，但不推荐 由于保存浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript 会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。同样地，如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数，如下面的例子所示： 12var floatNum1 = 1.; // 小数点后面没有数字——解析为1var floatNum2 = 10.0; // 整数——解析为10 对于那些极大或极小的数值，可以用 e 表示法（即科学计数法）表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMAScript 中 e 表示法的格式也是如此，即前面是一个数值（可以是整数也可以是浮点数），中间是一个大写或小写的字母E，后面是 10 的幂中的指数，该幂值将用来与前面的数相乘。下面是一个使用 e 表示法表示数值的例子： 1var floatNum = 3.125e7; // 等于31250000 在这个例子中，使用e 表示法表示的变量floatNum 的形式虽然简洁，但它的实际值则是31250000。在此，e 表示法的实际含义就是“3.125 乘以107”。也可以使用e 表示法表示极小的数值，如0.00000000000000003，这个数值可以使用更简洁的3e-17表示。在默认情况下，ECMASctipt 会将那些小数点后面带有6 个零以上的浮点数值转换为以e 表示法表示的数值（例如，0.0000003 会被转换成3e-7）。 浮点数值的最高精度是17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。例如： 123if (a + b == 0.3){ // 不要做这样的测试！ alert(\"You got 0.3.\");} 在这个例子中，我们测试的是两个数的和是不是等于0.3。如果这两个数是0.05 和0.25，或者是0.15和0.15 都不会有问题。而如前所述，如果这两个数是0.1 和0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家；其他使用相同数值格式的语言也存在这个问题。 数值范围由于内存的限制，ECMAScript 并不能保存世界上所有的数值。ECMAScript 能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是5e-324；能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript 数值范围的值，那么这个数值将被自动转换成特殊的Infinity 值。具体来说，如果这个数值是负数，则会被转换成 -Infinity（负无穷），如果这个数值是正数，则会被转换成 Infinity（正无穷）。 如上所述，如果某次计算返回了正或负的Infinity 值，那么该值将无法继续参与下一次的计算，因为Infinity 不是能够参与计算的数值。要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用isFinite() 函数。这个函数在参数位于最小与最大数值之间时会返回true，如下面的例子所示： 12var result = Number.MAX_VALUE + Number.MAX_VALUE;alert(isFinite(result)); //false 尽管在计算中很少出现某些值超出表示范围的情况，但在执行极小或极大数值的计算时，检测监控这些值是可能的，也是必需的。 访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以得到负和正Infinity 的值。可以想象，这两个属性中分别保存着 -Infinity 和 Infinity。 NaNNaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以非数值都会导致错误，从而停止代码执行。但在ECMAScript 中，任何数值除以非数值会返回NaN，因此不会影响其他代码的执行。 NaN 本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回false： 1alert(NaN == NaN); //false 针对NaN 的这两个特点，ECMAScript 定义了 isNaN() 函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后，会尝试将这个值转换为数值。某些不是数值的值会直接转换为数值，例如字符串”10”或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回true。请看下面的例子： 12345alert(isNaN(NaN)); //truealert(isNaN(10)); //false（10 是一个数值）alert(isNaN(\"10\")); //false（可以被转换成数值10）alert(isNaN(\"blue\")); //true（不能转换成数值）alert(isNaN(true)); //false（可以被转换成数值1） 这个例子测试了5 个不同的值。测试的第一个值是NaN 本身，结果当然会返回true。然后分别测试了数值10 和字符串”10”，结果这两个测试都返回了false，因为前者本身就是数值，而后者可以被转换成数值。但是，字符串”blue”不能被转换成数值，因此函数返回了true。由于Boolean 值true可以转换成数值1，因此函数返回false。 尽管有点儿不可思议，但 isNaN() 确实也适用于对象。在基于对象调用 isNaN() 函数时，会首先调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，则基于这个返回值再调用 toString() 方法，再测试返回值。 数值转换有3 个函数可以把非数值转换为数值：Number()、parseInt() 和 parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这3 个函数对于同样的输入会有返回不同的结果。 Number()函数的转换规则如下： 如果是Boolean 值，true 和false 将分别被转换为1 和0。 如果是数字值，只是简单的传入和返回。 如果是null 值，返回0。 如果是undefined，返回NaN。 如果是字符串，遵循下列规则： 如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即”1”会变成1，”123”会变成123，而”011”会变成11（注意：前导的零被忽略了）； 如果字符串中包含有效的浮点格式，如”1.1”，则将其转换为对应的浮点数值（同样，也会忽略前导零）； 如果字符串中包含有效的十六进制格式，例如”0xf”，则将其转换为相同大小的十进制整数值； 如果字符串是空的（不包含任何字符），则将其转换为0； 如果字符串中包含除上述格式之外的字符，则将其转换为NaN。 如果是对象，则调用对象的valueOf()方法，然后依照前面的规则转换返回的值。如果转换的结果是NaN，则调用对象的toString()方法，然后再次依照前面的规则转换返回的字符串值。 根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧。 1234var num1 = Number(\"Hello world!\"); //NaNvar num2 = Number(\"\"); //0var num3 = Number(\"000011\"); //11var num4 = Number(true); //1 首先，字符串”Hello world!”会被转换为NaN，因为其中不包含任何有意义的数字值。空字符串会被转换为0。字符串”000011”会被转换为11，因为忽略了其前导的零。最后，true 值被转换为1。 一元加操作符的操作与Number()函数相同。 由于Number()函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回NaN；也就是说，用parseInt()转换空字符串会返回NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。 如果字符串中的第一个字符是数字字符，parseInt()也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以”0x”开头且后跟数字字符，就会将其当作一个十六进制整数；如果字符串以”0”开头且后跟数字字符，则会将其当作一个八进制数来解析。 为了更好地理解parseInt()函数的转换规则，下面给出一些例子： 1234567var num1 = parseInt(\"1234blue\"); // 1234var num2 = parseInt(\"\"); // NaNvar num3 = parseInt(\"0xA\"); // 10（十六进制数）var num4 = parseInt(22.5); // 22var num5 = parseInt(\"070\"); // 56（八进制数）var num6 = parseInt(\"70\"); // 70（十进制数）var num7 = parseInt(\"0xf\"); // 15（十六进制数） 在使用parseInt()解析像八进制字面量的字符串时，ECMAScript 3 和5 存在分歧。例如： 12//ECMAScript 3 认为是56（八进制），ECMAScript 5 认为是70（十进制）var num = parseInt(\"070\"); 在ECMAScript 3 JavaScript 引擎中，”070”被当成八进制字面量，因此转换后的值是十进制的56。而在ECMAScript 5 JavaScript 引擎中，parseInt()已经不具有解析八进制值的能力，因此前导的零会被认为无效，从而将这个值当成”70”，结果就得到十进制的70。在ECMAScript 5 中，即使是在非严格模式下也会如此。 为了消除在使用parseInt()函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数16 作为第二个参数，可以保证得到正确的结果，例如： 1var num = parseInt(\"0xAF\", 16); //175 实际上，如果指定了16 作为第二个参数，字符串可以不带前面的”0x”，如下所示： 12var num1 = parseInt(\"AF\", 16); //175var num2 = parseInt(\"AF\"); //NaN 这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt()要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就自动终止了。 指定基数会影响到转换的输出结果。例如： 1234var num1 = parseInt(\"10\", 2); //2 （按二进制解析）var num2 = parseInt(\"10\", 8); //8 （按八进制解析）var num3 = parseInt(\"10\", 10); //10 （按十进制解析）var num4 = parseInt(\"10\", 16); //16 （按十六进制解析） 不指定基数意味着让parseInt()决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。 多数情况下，我们要解析的都是十进制数值，因此始终将10 作为第二个参数是非常必要的。 与parseInt()函数类似，parseFloat()也是从第一个字符（位置0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，”22.34.5”将会被转换为22.34。 除了第一个小数点有效之外，parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。以下是使用parseFloat()转换数值的几个典型示例。 123456var num1 = parseFloat(\"1234blue\"); //1234 （整数）var num2 = parseFloat(\"0xA\"); //0var num3 = parseFloat(\"22.5\"); //22.5var num4 = parseFloat(\"22.34.5\"); //22.34var num5 = parseFloat(\"0908.5\"); //908.5var num6 = parseFloat(\"3.125e7\"); //31250000 String 类型String 类型用于表示由零或多个16 位Unicode 字符组成的字符序列，即字符串。字符串可以由双引号（”）或单引号（’）表示，因此下面两种字符串的写法都是有效的： 12var firstName = \"Nicholas\";var lastName = 'Zakas'; 与 PHP 中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript 中的这两种语法形式没有什么区别。用双引号表示的字符串和用单引号表示的字符串完全相同。不过，以双引号开头的字符串也必须以双引号结尾，而以单引号开头的字符串必须以单引号结尾。例如，下面这种字符串表示法会导致语法错误： 12var firstName = 'Nicholas\"; // 语法错误 左右引号必须匹配 字符字面量String 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印字符，或者具有其他用途的字符。这些字符字面量如下表所示： 字面量 含义 \\n 换行 \\t 制表 \\b 退格 \\r 回车 \\f 禁止 \\ 斜杠 \\” “ \\xnn 以十六进制代码nn表示的一个字符（其中n为0～F）。例如，\\x41表示”A” \\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0～F）。例如，\\u03a3表示希腊字符Σ 这些字符字面量可以出现在字符串中的任意位置，而且也将被作为一个字符来解析，如下面的例子所示： 1var text = \"This is the letter sigma: \\u03a3.\"; 这个例子中的变量text 有28 个字符，其中6 个字符长的转义序列表示1 个字符。任何字符串的长度都可以通过访问其length 属性取得，例如： 1alert(text.length); // 输出28 这个属性返回的字符数包括16 位字符的数目。如果字符串中包含双字节字符，那么 length 属性可能不会精确地返回字符串中的字符数目。 字符串的特点ECMAScript 中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量，例如： 12var lang = \"Java\";lang = lang + \"Script\"; 以上示例中的变量lang 开始时包含字符串”Java”。而第二行代码把lang 的值重新定义为”Java”与”Script”的组合，即”JavaScript”。实现这个操作的过程如下：首先创建一个能容纳10 个字符的新字符串，然后在这个字符串中填充”Java”和”Script”，最后一步是销毁原来的字符串”Java”和字符串”Script”，因为这两个字符串已经没用了。这个过程是在后台发生的，而这也是在某些旧版本的浏览器（例如版本低于1.0 的Firefox、IE6 等）中拼接字符串时速度很慢的原因所在。但这些浏览器后来的版本已经解决了这个低效率问题。 转换为字符串要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的 toString() 方法。这个方法唯一要做的就是返回相应值的字符串表现。来看下面的例子： 1234var age = 11;var ageAsString = age.toString(); // 字符串\"11\"var found = true;var foundAsString = found.toString(); // 字符串\"true\" 数值、布尔值、对象和字符串值（没错，每个字符串也都有一个 toString() 方法，该方法返回字符串的一个副本）都有 toString() 方法。但 null 和 undefined 值没有这个方法。 多数情况下，调用 toString() 方法不必传递参数。但是，在调用数值的 toString() 方法时，可以传递一个参数：输出数值的基数。默认情况下，toString() 方法以十进制格式返回数值的字符串表示。而通过传递基数，toString()可以输出以二进制、八进制、十六进制，乃至其他任意有效进制格式表示的字符串值。下面给出几个例子： 123456var num = 10;alert(num.toString()); // \"10\"alert(num.toString(2)); // \"1010\"alert(num.toString(8)); // \"12\"alert(num.toString(10)); // \"10\"alert(num.toString(16)); // \"a\" 通过这个例子可以看出，通过指定基数，toString() 方法会改变输出的值。而数值 10 根据基数的不同，可以在输出时被转换为不同的数值格式。注意，默认的（没有参数的）输出值与指定基数 10 时的输出值相同。 在不知道要转换的值是不是null 或undefined 的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。String()函数遵循下列转换规则： 如果值有toString()方法，则调用该方法（没有参数）并返回相应的结果； 如果值是null，则返回”null”； 如果值是undefined，则返回”undefined”。 下面看几个例子： 12345678var value1 = 10;var value2 = true;var value3 = null;var value4;alert(String(value1)); // \"10\"alert(String(value2)); // \"true\"alert(String(value3)); // \"null\"alert(String(value4)); // \"undefined\" 这里先后转换了4 个值：数值、布尔值、null 和undefined。数值和布尔值的转换结果与调用toString()方法得到的结果相同。因为 null 和 undefined 没有toString()方法，所以String()函数就返回了这两个值的字面量。 要把某个值转换为字符串，可以使用加号操作符把它与一个字符串（””）加在一起。 Object 类型ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行new 操作符后跟要创建的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和（或）方法，就可以创建自定义对象，如下所示： 1var o = new Object(); 这个语法与Java 中创建对象的语法相似；但在ECMAScript 中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。也就是说，在像前面这个示例一样不传递参数的情况下，完全可以省略那对圆括号（但这不是推荐的做法）： 1var o = new Object; // 有效，但不推荐省略圆括号 仅仅创建 Object 的实例并没有什么用处，但关键是要理解一个重要的思想：即在ECMAScript 中，（就像Java 中的java.lang.Object 对象一样）Object 类型是所有它的实例的基础。换句话说，Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。 Object 的每个实例都具有下列属性和方法： constructor：保存着用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就是 Object()。 hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(\"name\")）。 isPrototypeOf(object)：用于检查传入的对象是否是当前对象的原型。 propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in 语句来枚举。与 hasOwnProperty() 方法一样，作为参数的属性名必须以字符串形式指定。 toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。 toString()：返回对象的字符串表示。 valueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString() 方法的返回值相同。 由于在ECMAScript 中Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。 从技术角度讲，ECMA-262 中对象的行为不一定适用于JavaScript 中的其他对象。浏览器环境中的对象，比如BOM 和DOM 中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象，因此宿主对象可能会也可能不会继承Object。","categories":[{"name":"JavaScript高级程序设计","slug":"JavaScript高级程序设计","permalink":"http://www.bestcsser.cc/categories/JavaScript高级程序设计/"}],"tags":[{"name":"数据类型","slug":"数据类型","permalink":"http://www.bestcsser.cc/tags/数据类型/"}]},{"title":"[转载]HTTP消息头（HTTP headers）－HTTP请求头与HTTP响应头","slug":"http-headers","date":"2017-04-18T03:16:55.000Z","updated":"2017-04-23T05:51:33.000Z","comments":true,"path":"2017/04/18/http-headers/","link":"","permalink":"http://www.bestcsser.cc/2017/04/18/http-headers/","excerpt":"","text":"转载：HTTP消息头（HTTP headers）－HTTP请求头与HTTP响应头 HTTP协议将传输的信息分隔为两部分：HTTP信息头、HTTP信息体。通过HTTP头信息，使客户端请求服务器资源或服务器响应客户端请求时，可以传递额外的信息。HTTP头信息格式为名称:值，名称不区分大小写，如：Content-Type: text/html 。通过HTTP消息头，可以使服务器或客户端了解对方所使用的协议版本、内容类型、编码方式等。 HTTP消息头分类在HTTP消息头中，有些是客户端特有的，有些是服务端所特有的，也有些是消息头是通用的。按HTTP消息头出现的上下文环境，有以下分类： 通用头HTTP消息头中，有些既适用于客户端的请求头，也适用于服务端的响应头，与HTTP消息体内最终传输的数据是无关的，只适用于要发送的消息。这些消息头由于HTTP协议版本的不同可能会有所区别，在 HTTP/1.1 中，这些消息头有：Cache-Control:、Connection:、Date:、 Pragma:、Trailer:、Transfer-Encoding:、Upgrade:、 Via:、Warning: 。 请求头HTTP 请求头为所请求的资源或请求本身，提供了更为精确的描述信息。其中有些缓存相关头描述了缓存信息，这些头会改变GET请求时获取资源的方式，如：If-Modified-Since 。有些消息头描述了用户偏好，如： Accept-Language 和 Accept-Charset 表示客户端所使用语言及编码方式、User-Agent 表示客户端的代理方式。 新增加的请求头不能在旧的HTTP版本中使用，但是，如果服务器和客户端都能对相关头进行处理，就可以在请求中使用。在这种情况下，客户端不应该假定服务器有对相关头的处理能力。未知的请求头被处理为实体头。 响应头HTTP 响应头为响应消息提供了更多信息。如，关于资源位置的描述 Location :，关于务器本身的描述使用 Server : 新增加的响应头不能在旧的HTTP版本中使用，但是，如果服务器和客户端都能对相关头进行处理，就可以在响应中使用。在这种情况下，服务器不应该假定客户端有对相关头的处理能力。未知的响应头被处理为实体头。 实体头HTTP 实体头提供了关于消息体的描述。如，消息体的长度 Content-Length :，消息体的MIME类型 Content-Type :。新的实体头可以旧HTTP版本中使用。 HTTP消息头也可以按缓存与百缓存的处理方式分分类： 端到端（End-To-End）头End-To-End 头信息必须发送到消息的最终接收人，即：接收请求消息的服务器或接收响应消息的客户端。这些头信息意味着中间代理必须重发未修改的内容，也必须存储缓存。 End-To-End 头在一个路由器连接的两种物理网络中使用，即：OSI 的应用层和运输层。 逐跳（Hop-By-Hop）头Hop-By-Hop 头被单一的传输层连接使用，Hop-By-Hop 头标识传输内容不得通过代理或缓存转发。这些头信息有：Connection:、Keep-Alive:、Proxy-Authenticate:、Proxy-Authorization:、 TE:、Trailers:、Transfer-Encoding:、Upgrade: 。注意，只有 Hop-By-Hop 头可能会设置使用 Connection : 通用头。 一些有用的请求头众多的HTTP请求头中，有几个是特别有用且应当正确设置的。如果你要创建HTTP请求，如，创建 XMLHttpRequest 或一个延时写入并通过XPCOM发送自定义的HTTP请求时，这时确保正确写入请求头就非常重要，进行这些操作时，用户使用浏览器一般自动写入请求头。 控制所访问资源的语言大多数用户所使用的浏览器客户端，如：Firefox，都允许用户设置所偏好的语言，设置后浏览器会在发送请求时添加一个 Accept-Language : 头信息。而服务器，在收到HTTP请求时，也可以根据这个头信息返回对应语言的资源。 有条件GET请求缓存是提高网站访问速度的重要方式，当使用 XMLHttpRequest 进行部分页面数据的刷新时，使用 If-Modified-Since ：头信息会告诉服务器，访问更新过的内容，可以有效的提高访问效率。 一些有用的响应头正确的配置网站服务器，是保证网站性能和安全的关键。在众多的HTTP响应头中，有几个响应头是比较重要性且应当配置在服务器中。 框架（frame）控制几个跨站脚本（XSS）攻击，就是利用第三方框架（frame或iframe）。现代浏览器已经支持 CSPframe-ancestors 指令，在服务器端将其设置为”none”，可以有效访止浏览器在框架内显示该资源，使用它的关键资源（如：表单数据或关键信息）可以有效减少 XSS 攻击风险。注意，这个响应头并不是缓解XSS风险的唯一途径，也可通过一些内容安全策略实现。 数据压缩最大限度地减少传输的数据量，可以有效加速了网页的显示。虽然可以通Gulp等工具，将静态文件数据压缩。但如果要压缩传输数据，那么必须在Web服务器级别进行相关配置。设置后，客户端会发送一个 Accept-Encoding :头，告诉服务器所接受的编码方式；而服务器也会响应一个 Content-Encoding :头，告诉客户端所使用的压缩方式。 注：Nginx 服务器可以通过配置 Gzip 实现数据压缩。 缓存控制HTTP缓存是提高网站访问速度另一种有效方式，它可防止同一未修改资源被多次访问。正确的配置服务器的响应头，可以使用户代理（浏览中器）充分缓存数据。 配置缓存时，需要设置以下项： 任何静态资源都应该提供了一个 Expires :响应头。这样，资源可以用户代理达到它自身限制前（如：达到缓存大小限制），充分的缓存数据。任何动态资源都应该提供了一个 Cache-control :响应头。理论上讲，所有安全的HTTP方法(GET、HEAD)甚至幂等方法(DELETE、PUT)，都可以配置缓存，但在实际使用中会有一些问题。 设置MIME类型MIME 类型响应头 Content-type 会告诉客户端传输文档的类型，扩展名在文档的网络传中已经失去意义。正确配置服务器此项设置，对文件传输非常重要，用户代理客户端经常通过MIME类型判断文档的打开方式或获取资源后的默认动作。","categories":[{"name":"其他","slug":"其他","permalink":"http://www.bestcsser.cc/categories/其他/"}],"tags":[{"name":"http","slug":"http","permalink":"http://www.bestcsser.cc/tags/http/"}]},{"title":"[转载]HTTP请求方法：GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE","slug":"http-request-methods","date":"2017-04-18T02:56:17.000Z","updated":"2017-04-23T05:51:33.000Z","comments":true,"path":"2017/04/18/http-request-methods/","link":"","permalink":"http://www.bestcsser.cc/2017/04/18/http-request-methods/","excerpt":"","text":"转载： HTTP请求方法：GET、HEAD、POST、PUT、DELETE、CONNECT、OPTIONS、TRACE 超文本传输协议（HTTP, HyperText Transfer Protocol）是一种无状态的协议，它位于 OSI七层模型 的传输层。HTTP客户端会根据需要构建合适的HTTP请求方法，而HTTP服务器会根据不同的HTTP请求方法做出不同的响应。 HTTP版本与HTTP请求方法在HTTP的发展过程中，出现了很多HTTP版本，其中的大部分协议都是向下兼容的。在进行HTTP请求时，客户端在请求时会告诉服务器它采用的协议版本号，而服务器则会在使用相同或者更早的协议版本进行响应。 HTTP/0.9这是HTTP最早大规模使用的版，现已过时。在这个版本中 只有GET一种请求方法，在HTTP通讯也没有指定版本号，也不支持请求头信息。该版本不支持POST等方法，因此客户端向服务器传递信息的能力非常有限。HTTP/0.9的请求只有如下一行： 1GET www.itbilu.com HTTP/1.0这个版本是第一个在HTTP通讯中指定版本号的协议版本，HTTP/1.0至今仍被广泛采用，特别是在代理服务器中。 HTTP/1.0 支持： GET、POST、HEAD 三种HTTP请求方法。 HTTP/1.1HTTP/1.1 是当前正在使用的版本。该版本默认采用持久连接，并能很好地配合代理服务器工作。还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。 HTTP/1.1 新增了： OPTIONS、PUT、DELETE、TRACE、CONNECT 五种HTTP请求方法。 HTTP/2这个版本是最新发布的版本，于今年5月（2015年5月）做HTTP标准正式发布。HTTP/2 通过支持请求与相应的多路重用来减少延迟，通过压缩HTTP头字段将协议开销降到最低，同时增加了对请求优先级和服务器端推送的支持。 HTTP请求方法介绍HTTP/1.1 协议中共定义了8种HTTP请求方法，HTTP请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。 GETGET 请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。 GET 会方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。 HEADHEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。 POSTPOST 请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。 PUTPUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。 DELETEDELETE 请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE 请求后指定资源会被删除，DELETE 方法也是幂等的。 CONNECTCONNECT 方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。 OPTIONSOPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用’*’来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 TRACETRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。 HTTP/1.1 之后增加的方法 在 HTTP/1.1 标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法： PATCHPATCH 方法出现的较晚，它在2010年的RFC 5789标准中被定义。PATCH 请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同： 但PATCH一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。 当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。","categories":[{"name":"其他","slug":"其他","permalink":"http://www.bestcsser.cc/categories/其他/"}],"tags":[{"name":"http","slug":"http","permalink":"http://www.bestcsser.cc/tags/http/"}]},{"title":"[转载]悟透JavaScript","slug":"javascript-zen","date":"2017-04-07T06:15:30.000Z","updated":"2017-04-17T14:53:37.000Z","comments":true,"path":"2017/04/07/javascript-zen/","link":"","permalink":"http://www.bestcsser.cc/2017/04/07/javascript-zen/","excerpt":"","text":"转载：悟透JavaScript 引子编程世界里只存在两种基本元素，一个是数据，一个是代码。编程世界就是在数据和代码千丝万缕的纠缠中呈现出无限的生机和活力。 数据天生就是文静的，总想保持自己固有的本色；而代码却天生活泼，总想改变这个世界。 你看，数据代码间的关系与物质能量间的关系有着惊人的相似。数据也是有惯性的，如果没有代码来施加外力，她总保持自己原来的状态。而代码就象能量，他存在的唯一目的，就是要努力改变数据原来的状态。在代码改变数据的同时，也会因为数据的抗拒而反过来影响或改变代码原有的趋势。甚至在某些情况下，数据可以转变为代码，而代码却又有可能被转变为数据，或许还存在一个类似E=MC2形式的数码转换方程呢。然而，就是在数据和代码间这种即矛盾又统一的运转中，总能体现出计算机世界的规律，这些规律正是我们编写的程序逻辑。 不过，由于不同程序员有着不同的世界观，这些数据和代码看起来也就不尽相同。于是，不同世界观的程序员们运用各自的方法论，推动着编程世界的进化和发展。 众所周知，当今最流行的编程思想莫过于面向对象编程的思想。为什么面向对象的思想能迅速风靡编程世界呢？因为面向对象的思想首次把数据和代码结合成统一体，并以一个简单的对象概念呈现给编程者。这一下子就将原来那些杂乱的算法与子程序，以及纠缠不清的复杂数据结构，划分成清晰而有序的对象结构，从而理清了数据与代码在我们心中那团乱麻般的结。我们又可以有一个更清晰的思维，在另一个思想高度上去探索更加浩瀚的编程世界了。 在五祖弘忍讲授完《对象真经》之后的一天，他对众弟子们说：“经已讲完，想必尔等应该有所感悟，请各自写个偈子来看”。大弟子神秀是被大家公认为悟性最高的师兄，他的偈子写道：“身是对象树，心如类般明。朝朝勤拂拭，莫让惹尘埃！”。此偈一出，立即引起师兄弟们的轰动，大家都说写得太好了。只有火头僧慧能看后，轻轻地叹了口气，又随手在墙上写道：“对象本无根，类型亦无形。本来无一物，何处惹尘埃？”。然后摇了摇头，扬长而去。大家看了慧能的偈子都说：“写的什么乱七八糟的啊，看不懂”。师父弘忍看了神秀的诗偈也点头称赞，再看慧能的诗偈之后默然摇头。就在当天夜里，弘忍却悄悄把慧能叫到自己的禅房，将珍藏多年的软件真经传授于他，然后让他趁着月色连夜逃走… 后来，慧能果然不负师父厚望，在南方开创了禅宗另一个广阔的天空。而慧能当年带走的软件真经中就有一本是《JavaScript真经》！ 回归简单要理解JavaScript，你得首先放下对象和类的概念，回到数据和代码的本原。前面说过，编程世界只有数据和代码两种基本元素，而这两种元素又有着纠缠不清的关系。JavaScript就是把数据和代码都简化到最原始的程度。 JavaScript中的数据很简洁的。简单数据只有 undefined, null, boolean, number和string这五种，而复杂数据只有一种，即object。这就好比中国古典的朴素唯物思想，把世界最基本的元素归为金木水火土，其他复杂的物质都是由这五种基本元素组成。 JavaScript中的代码只体现为一种形式，就是function。 注意：以上单词都是小写的，不要和Number, String, Object, Function等JavaScript内置函数混淆了。要知道，JavaScript语言是区分大小写的呀! 任何一个JavaScript的标识、常量、变量和参数都只是unfined, null, bool, number, string, object 和 function类型中的一种，也就typeof返回值表明的类型。除此之外没有其他类型了。 先说说简单数据类型吧。 1234567891011121314151617181920undefined//代表一切未知的事物，啥都没有，无法想象，代码也就更无法去处理了。//注意：typeof(undefined) 返回也是 undefined。//可以将undefined赋值给任何变量或属性，但并不意味了清除了该变量，反而会因此多了一个属性。null//有那么一个概念，但没有东西。无中似有，有中还无。虽难以想象，但已经可以用代码来处理了。//注意：typeof(null)返回object，但null并非object，具有null值的变量也并非object。boolean//是就是，非就非，没有疑义。对就对，错就错，绝对明确。既能被代码处理，也可以控制代码的流程。number//线性的事物，大小和次序分明，多而不乱。便于代码进行批量处理，也控制代码的迭代和循环等。//注意：typeof(NaN)和typeof(Infinity)都返回number 。//NaN参与任何数值计算的结构都是NaN，而且 NaN != NaN 。//Infinity / Infinity = NaN 。string//面向人类的理性事物，而不是机器信号。人机信息沟通，代码据此理解人的意图等等，都靠它了。 简单类型都不是对象，JavaScript没有将对象化的能力赋予这些简单类型。直接被赋予简单类型常量值的标识符、变量和参数都不是一个对象。 所谓“对象化”，就是可以将数据和代码组织成复杂结构的能力。JavaScript中只有object类型和function类型提供了对象化的能力。 没有类object就是对象的类型。在JavaScript中不管多么复杂的数据和代码，都可以组织成object形式的对象。 但JavaScript却没有 “类”的概念！ 对于许多面向对象的程序员来说，这恐怕是JavaScript中最难以理解的地方。是啊，几乎任何讲面向对象的书中，第一个要讲的就是“类”的概念，这可是面向对象的支柱。这突然没有了“类”，我们就象一下子没了精神支柱，感到六神无主。看来，要放下对象和类，达到“对象本无根，类型亦无形”的境界确实是件不容易的事情啊。 这样，我们先来看一段JavaScript程序： 123456789101112131415161718192021var life = {};for(life.age = 1; life.age","categories":[{"name":"javaScript日常笔记","slug":"javaScript日常笔记","permalink":"http://www.bestcsser.cc/categories/javaScript日常笔记/"}],"tags":[]},{"title":"[转载]Web 中文字体应用指南","slug":"web-chinese-fonts-guide","date":"2017-03-16T06:04:36.000Z","updated":"2017-03-18T16:06:56.000Z","comments":true,"path":"2017/03/16/web-chinese-fonts-guide/","link":"","permalink":"http://www.bestcsser.cc/2017/03/16/web-chinese-fonts-guide/","excerpt":"","text":"写在前面最近一个儿童教育机构的官网项目，碰上了字体处理的问题，本身解决各个平台对中文字体的相对友好的设置是件挺头疼的事儿，一般常见的方法就是设置 font-family: sans-serif; 即完全由各平台自己决定使用什么中文字体。 但是为了解决需求，去搜索了能够相对友好的中文字体设置方法：跨平台 CSS 中文字体解决方案 - zenozeng/fonts.css 下面的文字也详细的介绍了 web 中文字体的设置 作者：nightire Web 中文字体应用指南 Web 中文字体应用指南在 Web 上应用字体是一项基本技术，同时也是一门艺术。对于英文字体来说可选择的范围实在是太广泛了，合理的使用它们将会为你的网站增色不少。关于英文字体的使用和搭配技巧，在这里不做赘述，只推荐一套非常好的视频：Fundamentals of Design by CodeSchool 而真正的挑战在于中文字体，由于中文字体组成的特殊性导致其体积过于庞大，除了操作系统内置的字体之外，我们很难在网站上应用其他的字体。在可选性很差的前提之下，如何正确的使用中文字体呢？ 首先，以下的字体声明都是很糟糕的，切忌使用： 1234567font-family: \"宋体\";font-family: \"宋体\", Arial;font-family: Arial, \"宋体\", \"微软雅黑\";font-family: Helvetica, Arial, \"华文细黑\", \"微软雅黑\"; 接下来，我们一步一步来说明如何定义好的字体声明。 中文字体也有英文名称很多开发者忽略了这一点：尽管我们在操作系统中常常看到宋体、微软雅黑、华文细黑这样的字体名称，但实际上这只是字体的显示名称，而不是字体文件的名称。虽然说在大多数情况下直接使用显示名称也有效，但有些用户却工作在一些很极端的情况下，这会导致你的字体声明无效。 比如说，用户安装了中文版的操作系统（这意味着系统有中文字体），但是却切换到了以英文为主要语言——这种情况在那些希望加强英语锻炼的中文用户当中是很常见的。这时候，操作系统很有可能无法按照显示名称找到正确的字体，所以我们要记住的第一件事情就是： 同时声明中文字体的字体名称（英文）和显示名称（中文），就像这样： 12345font-family: SimSun, \"宋体\";font-family: \"Microsoft YaHei\", \"微软雅黑\";font-family: STXihei, \"华文细黑\", \"Microsoft YaHei\", \"微软雅黑\"; 永远不要忘记声明英文字体，并且英文字体应该在中文字体之前记住这个事实：绝大部分中文字体里包含英文字母（但是基本上都很丑），而英文字体里不包含中文字符。 在网页里中/英文混排是很常见的，你绝对不会喜欢用中文字体显示英文的效果，所以一定不要忘了先声明英文字体： 123font-family: Georgia, SimSun, \"宋体\";font-family: Arial, \"Microsoft YaHei\", \"微软雅黑\"; 另外还有一个好习惯，就是在最后补充英文字体族的名称。字体族大体上分为两类：非衬线和衬线，它们之间的区别和使用规则请见本文开始介绍的视频。一般来说，你应该这么做： 123font-family: Georgia, SimSun, \"宋体\", serif;font-family: Arial, \"Microsoft YaHei\", \"微软雅黑\", sans-serif; 请注意：以上两句声明中的 宋体 和 微软雅黑 不应该调换（尽管调换了也不会发生错误），这是因为从字体的式样来看，微软雅黑 是非衬线的，而宋体才是衬线的。然而中文并不像英文那样严格区分字体族，所以这一点在实际应用当中并不那么重要。 别忘了照顾不同的操作系统作为一个 Web 开发者，你理应对 Windows, Mac OS, Linux 家族等常用操作系统里的系统字体有足够的了解，特别是中文。在这里，我们假设目标网站要同时给予 windows 用户和 mac 用户最好的字体体验，于是我们可以这样声明： 1font-family: Helvetica, Tahoma, Arial, STXihei, \"华文细黑\", \"Microsoft YaHei\", \"微软雅黑\", sans-serif; 这句声明都做到哪些事情呢？让我们一一说明（括号内代表其对应的目标操作系统）： 对于英文字符，首先查找 Helvetica(Mac)，然后查找 Tahoma(Win)，都找不到就用 Arial(Mac&Win)；若是以上三者都缺失，则使用当前默认的 sans-serif 字体(操作系统或浏览器指定)； 对于中文字体，我们已经了解其规则了。华文细黑(Mac)，微软雅黑(Win)是这两个平台的默认中文字体。 注意向下兼容到此为止，我们的字体声明已经很不错了——如果你不必考虑还在使用旧版本操作系统的用户的话。遗憾地是，中文市场还有大量的用户在使用 Windows XP，宋体 才是他们的主要中文字体。为了照顾到这些用户，你可以为 微软雅黑 增加一个 fallback： 1font-family: Helvetica, Tahoma, Arial, STXihei, \"华文细黑\", Heiti, \"黑体\", \"Microsoft YaHei\", \"微软雅黑\", SimSun, \"宋体\", sans-serif; 同样地，你看到我们也为 Mac 系统使用了 黑体 作为 fallback。 其他不加双引号可以吗？可以。有些英文字体的名称多于两个单词，因为单词中间有空格所以需要用 \"\" 包裹起来。中文字体很特别，按照英文的角度来看，像微软雅黑究竟算是一个词还是四个词呢？没关系，好在中文字体的名称里没有空格，所以 \"\" 不加也没什么大碍。 不过，谁都不能保证在任何操作系统/浏览器环境下都是如此，若是发生了奇怪的事情，不妨加上双引号试试看。 可以默认显示某种字体吗？比如微软雅黑你可能注意到了，在我们最后的字体声明里，华文细黑 是默认字体（如果你的系统上安装了声明里所有的中文字体的话），为什么我要先声明 Mac 系统的字体呢？ 按理来说，大多数网站的主要目标市场还是 Windows 用户的，所以理论上这个才是合理的声明： 1font-family: Helvetica, Tahoma, Arial, \"Microsoft YaHei\", \"微软雅黑\", SimSun, \"宋体\", STXihei, \"华文细黑\", Heiti, \"黑体\", sans-serif; 但实际上却并非如此。在中文字体的用户群体里，很大一部分拥有 Mac 的人都同时安装了 Win 下常用的中文字体（这得归功于 Office for Mac）；但极少有 Win 用户去安装 Mac 下的中文字体。 因此，把 Mac 用字体声明在前面几乎不会对 Win 用户产生什么影响（因为他们压根没有！），倒是用来做 fallback 的黑体可能会取代微软雅黑的位置，所以更保险的做法或许是这样： 1font-family: Helvetica, Tahoma, Arial, STXihei, \"华文细黑\", \"Microsoft YaHei\", \"微软雅黑\", SimSun, \"宋体\", Heiti, \"黑体\", sans-serif; 但无论如何请不要把 微软雅黑 放在中文字体的最前面，作为史上最丑陋的中文字体之一，微软雅黑 实在不是什么好的选择，请照顾一下被 Mac 宠坏的用户吧，谢谢！（仅代表个人观点） BTW，如果你也像我一样不喜欢呆头呆脑的 微软雅黑，那就干脆把它删了吧~ 到此为止，虽然在我们的示例代码里没有包含 Linux 家族的例子，不过相信你也明白该怎么做了吧。 一点补充鉴于一些人对 微软雅黑 的排位产生异议，我不妨把上文的解决方案再延伸一步。事实是这样子的： 把 微软雅黑 放前面，会导致安装了 微软雅黑 字体的 Mac 用户不得不面对 微软雅黑，而在 Mac 下比 微软雅黑 优雅得多的中文字体比比皆是； 把 Mac 下的字体放前面，也会对 Windows 用户造成差不多的困惑，毕竟微软雅黑是 Windows 平台下显示效果最好的字体（目前为止）；1 和 2，哪一种出现的概率更大一些？我想这是一个不需要计算就能知道的答案吧？ 但是——的确还有另外两个因素在纠结着： 不少 Windows 用户因为各种原因关闭了 ClearType，在此情形下微软雅黑将会惨不忍睹！但是 Mac 的字体也不是好的选择，真正的胜出者？猜对了，宋体。 绝大部分 Mac 下的黑体在 Windows 下模糊不清，而微软雅黑虽然丑但在 Mac 下至少能看。（间接体现了两个平台的字体渲染技术的差距） 所以在实践中，真正接近“万无一失”的方案需要考虑以下几点： 利用 UA 判断为不同的平台加载不一样的字体声明； 除非有特别的原因，否则尽量保持正文用宋体，标题和其他可以放大些的地方用 微软雅黑 （针对 Windows）； Mac 下的冬青体效果极佳，但是该字体在 Mac OS X 10.6 以前是没有的，所以谨慎考虑你的用户群体，或者使用华文黑体系列做 fallback； 最后，我不想再和任何人争论字体的优劣，本文的目的是介绍使用方法而不是字体选择。“美”或“丑”向来都是很主观的事情，只因为我是作者，所以我免不了会有倾向性，然而我也相信你自己会有正确的判断，和我较真没有任何实际意义。","categories":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.bestcsser.cc/categories/项目总结/"}],"tags":[{"name":"font","slug":"font","permalink":"http://www.bestcsser.cc/tags/font/"}]},{"title":"HTML5 audio 跨页面持续播放","slug":"html5-audio-across-pages-continues-play","date":"2017-01-17T03:48:40.000Z","updated":"2017-03-09T13:29:03.000Z","comments":true,"path":"2017/01/17/html5-audio-across-pages-continues-play/","link":"","permalink":"http://www.bestcsser.cc/2017/01/17/html5-audio-across-pages-continues-play/","excerpt":"","text":"写在前面继 上个H5活动 关于音乐跨页面持续播放的问题，没有在上个项目里解决掉，妥协使用每个页面重新播放。这次的H5活动同样也需要用到背景音乐。提前去搜索相关的文章，看能不能很好的解决这个问题。 过程关于跨页面持续播放音乐的场景，第一个想到的就是网易云音乐Web版的音乐播放，看了源码具体的DOM结构就是播放器和页面是分开的，页面是使用iFrame来展现，即使跳转页面，也只是在iFrame内跳转，这就解决了问题（我说的很肤浅）。 手机端显然是不能够用到iFrame的（一直很抵触使用iFrame）。只能再去查了。 currentTime 设置或返回当前播放位置（以秒计）。既然有了 currentTime ，问题是不是就是好解决了… 使用 localStorage 在跳转页面前把 currentTime 存储起来，再打开新的页面中，为音乐设置最新的 currentTime，这样以来音乐就能够在新打开的页面接着在上次跳转的时候播放了。 由于该活动是在朋友圈传播，之前有听说微信内置浏览器对 localStorage 的支持不够友好，关于这个问题查了很多文章，说的云里雾里，最后还是没结果。那就直接写吧。 遇到的问题及想到的最后代码的实现及在手机端的测试（小米4C，iphone6s/iphone7最新版微信），都能够实现在新打开的页面接着在上次跳转的时候播放。虽然问题是解决了，但在实际中体验还是不够好，每次打开新的页面，音乐都要重新加载一次，网络状况不好的情况，就很尴尬，等了许久音乐才继续播放，也可能在用户要进去下一个新的页面了，音乐还是没加载好。网络状况理想的情况下，表现还是不错的。 最后再想想这个事情，最简单直接的实现就是 单页面 来开发。就不用为音乐的事情犯愁了，当然音乐文件越小越理想。 这是地址 Fast-PK 关于audio/video video标签在不同平台上的事件表现差异分析 HTML5 Audio-使用 Media 事件添加进度栏","categories":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.bestcsser.cc/categories/项目总结/"}],"tags":[{"name":"audio","slug":"audio","permalink":"http://www.bestcsser.cc/tags/audio/"},{"name":"localStorage","slug":"localStorage","permalink":"http://www.bestcsser.cc/tags/localStorage/"}]},{"title":"H5皮秒游戏总结","slug":"h5-pimiao-game-project-summary","date":"2016-12-26T08:22:12.000Z","updated":"2017-02-05T06:37:32.000Z","comments":true,"path":"2016/12/26/h5-pimiao-game-project-summary/","link":"","permalink":"http://www.bestcsser.cc/2016/12/26/h5-pimiao-game-project-summary/","excerpt":"","text":"写在前面前段时间公司接的一个小项目，开发在微信上传播的小游戏。 游戏的流程就是提供三种瑕疵的美女图片斑点、皱纹、纹身，需要用户点击来擦除斑点、皱纹、纹身，并计时统计总的擦除用时，来进行排名。 接到项目的具体需求，心里想到的就是我们经常见到的刮刮乐，刮开图层显示中奖信息，这个原理跟要开发的小游戏基本一致，及擦除掉有斑点皱纹纹身的图层显示完美的一层即可。虽然这种效果经常遇见，具体的代码实现没有去看过。 过程首先，使用Canvas是肯定的了。能力的不过关，自己从0开始去写这个东西不太现实，网上搜到一些大神们写好的Demo，基本都能匹配这次开发的需求点。擦除瑕疵图层到指定百分比及显示完美图层并停止当前的计时。 找了几个例子，并在本地实现简单的Demo，实现过程中，也慢慢的发现跟自己开发不能匹配的问题，例如我需要这块的Canvas能够实现： 擦除动作（开始，结束）回调 自定义笔触大小 笔触边缘要柔和（虚化） 能够锁定画布，在达到指定擦除范围的百分比后我需要锁定画布，防止误操作 能够指定动作，项目只需要点击的动作，禁止手指移动来擦除 通过在Github上寻找，锁定了插件 wScratchPad 来完成这次的开发。 具体使用：12345678910111213141516171819202122// 设置$('#elem').wScratchPad({ size : 5, // 笔触尺寸 bg : '#cacaca', // 背景可以是颜色和图片 fg : '#6699ff', // 前景可以是颜色和图片（也就是需要擦掉的层） realtime : true, // 实时显示已擦除百分比 scratchDown : function(e, percent){ console.log(percent); }, scratchMove : function(e, percent){ console.log(percent); }, scratchUp : function(e, percent){ console.log(percent); }, cursor : 'crosshair' // 鼠标样式（可以是图片）});// 方法$('#elem').wScratchPad('reset'); // 重置画布$('#elem').wScratchPad('clear'); // 清除画布$('#elem').wScratchPad('enabled', ); // 是否开启 默认true 遇到的问题 插件本身笔触是生硬的，去查了下Canvas的API把笔触修改为边缘羽化效果，createRadialGradient 项目只需要点击擦除，禁止了手指移动擦除，插件基础上增加了 disabledMove: false 选项 处理音频(audio)遇到的问题音频资源是客户提供的网易云音乐的资源，根据网上的方法，找到了该资源的真实mp3地址，尽然2.4MB，真实很大啊，先不管大了。 音频这块，我一开始的思路：关于Audio 需要实现的是进入页面自动播放音乐，点击开关停止播放，音乐ICON停止转动。然后需要知道，音频资源当前状态是否可以用了，判断 readyState 的状态。然有点问题，我因该先去知道音频资源是否已经加载成功，才可以去知道它的当前状态说否可以播放。关于怎么知道加载成功，我参考了两篇文章 怎么判断 audio video 是否加载完，判断音乐是否加载怎么做？。其实最后上线，音频这块的优化我并没有做，找的理由就是催的及，懒得搞，我先给你上线再说吧。 关于自动播放，在iPhone7的微信浏览器中是不自动播放的，于是又去查到这个 轻松化解iOS系统及微信中不支持audio自动播放问题，根据这个方法，自动播放的问题解决了。 关于音乐持续播放的问题，因为跨页面了，貌似让一首音乐持续接着播放好像不容易实现，去看了下API， currentTime 设置或返回音频中的当前播放位置（以秒计）。我想法是在跳转也时候把 currentTime 的值通过 URL 传到下一页去，在下一页中去指定 audio 的 currentTime。在我去查这个问题的时候，好像没有看到关于 currentTime 的思路，想想也是，如果跳转挺多页的话岂不是要玩儿死，所以这个思路肯定是行不通的。 有空我要先Demo下 currentTime 是个什么情况，及一些网易云音乐Web版是怎么做的。 CSS3动画性能发现使用 box-shadow 来做闪烁的效果，几个同时闪烁，会有明显的卡顿现象（小米4C），如果 用边缘羽化过的图片 来替换box-shadow的话，卡顿现象消失了。这里有两篇关于CSS3动画性能的文章： 高性能 CSS3 动画 CSS动画之硬件加速 还可以更好的地方 图片资源的预加载 音频资源的预加载 JS文件合并 手机上如果快速点击的话，擦除的速度会有明显的慢（小米4C） 页面布局也需要花点时间再去调试 吐槽 能力不够就是累啊，加油吧。 开发前再三的确认设计是否定稿，结果还是因为设计返工，整个重新整。WTF!!! 致所有的UI设计师们，提供的PSD不分组命名是几个意思，量少就不说了。TM 一大堆形似图层副本的玩意儿，太浪费别人的时间了，当代码搬运工也很累的。 线上地址，因为需要用户提供姓名和手机才可以进入，程序这块有明显的体验问题，比如第二天再来还是需要重新输入，而且程序走的是手机号不能重复，然并没有任何提示，输入不同的昵称相同的手机号，排行显示的是首次使用的昵称，解决记住登录状态的问题就OK了。 最后最后，希望自己下次能更好吧，至少不犯过去的Bugs。","categories":[{"name":"项目总结","slug":"项目总结","permalink":"http://www.bestcsser.cc/categories/项目总结/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2016-12-06T08:56:29.000Z","updated":"2016-12-18T06:15:06.000Z","comments":true,"path":"2016/12/06/hello-world/","link":"","permalink":"http://www.bestcsser.cc/2016/12/06/hello-world/","excerpt":"","text":"那就开始吧，或许还不晚。 123var javaScript = { // ...}","categories":[],"tags":[]}]}